## 生产者消费者模式
	利用生产者、消费者和中间的消息缓冲区来实现的，解耦合，且可以并发执行，提升程序效率。
	可以利用阻塞队列
	可以利用管道流机制，但是管道流仅支持单向传输
	可以利用锁加wait()\notify()通知唤醒机制
	也可以利用socket机制来实现
## 策略模式
	在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改，是由调用者决定的。这种类型的设计模式属于行为型模式。
	在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变context对象的执行算法。
	比如，定义一个出行工具的抽象类（抽象策略接口），以及实现了该类的各个具体出行工具的子类（具体策略类）。然后定义一个context环境类。
	最后在具体实现该Context对象的时候传入具体的出行工具对象来是实现具体的出行方式。
	优点：策略模式遵循开闭原则，实现代码的解耦合。扩展新的方法时也比较方便，只需要继承策略接口就好了。
	缺点：实现者需要知道所有的策略类，并自行决定使用哪一个；继承的特点使得策略类对于不要使用的变量也一并继承并进行了初始化
## 工厂模式
	一种创建型模式，它提供了一种创建对象的最佳方式。
	在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
	需要一个抽象接口以及实现了该接口的具体类，以及一个工厂类。
	优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 
	缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。
	使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。 

## 状态模式
	在状态模式中，类的行为是由其状态决定的，也是一种行为型模式。
	需要定义一个 State 接口和实现了 State 接口的实体状态类，以及是一个带有某个状态的类Context
	优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 
	缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 
	使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。。