线程私有的程序计数器、虚拟机栈和本地方法栈的内存大小在编译期间可知，生命周期是随着线程或者方法的开始而开始，结束而结束。
而线程共享的堆和方法区不一样，只有在程序执行期间才知道需要创建多少个对象以及一个方法不同分支的内存分配。

1、哪些内存需要回收
2、什么时候回收
3、怎么回收


对象是否存活的判断：
	1、java引用：JDK1.2之后，java对引用的概念进行了扩充，分为强引用、软引用、弱引用和虚引用四种，引用强度逐渐减弱。
			强引用：程序代码中普遍存在的，比如Object a = new Object()。当强引用还存在时，垃圾回收器永远不会回收被引用的对象。
			软引用：用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常时，将这些对象列入回收范围进行第二次回收，如果本次回收还是没有足够的内存时，才会抛出内存溢出异常。java.lang.ref.SoftReference，适合用来实现缓存：比如网页缓存、图片缓存等。
			弱引用：描述非必需对象，被弱引用的对象只能生存到下一次垃圾收集发生之前。WeakReference
			虚引用：最弱的一种引用关系，又称幽灵引用或者幻影引用。一个对象是否存在虚引用，完全不会对其生存时间造成影响，也无法通过一个虚引用来获得一个对象实例。该引用存在的唯一目的是在这个对象被垃圾收集器回收时收到一个系统通知。PhantomReference
			注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
	2、引用计数法：每个对象维护一个引用计数器，当有一个地方引用它时，计数器加1，如果引用失效时，计数器减1.任何时刻当计数器为0的对象是不可能再被使用的。
				优点：实现简单，判定效率高。
				缺点：无法解决对象之间相互引用的循环问题。
				虚拟机并没有用该方法来判断你对象是否存活。
	3、可达性分析算法：通过一系列被称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则这个对象是不可用的，被判为可回收对象。
						GC Roots可以理解为由堆外指向堆内的引用， 一般而言，包括：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象。
						可达性分析算法中的不可达对象会被标记并筛选是否需要执行finalize()方法，如果需要执行，则将该对象置入F-Queue队列中，等待一个由虚拟机自动建立的低优先级的finalizer线程去执行。finalize()方法是对象避免被GC的唯一一次机会，因为一个对象的finalize()方法置多被系统调用一次。
						然后GC会对F-Queue队列中的对象进行二次标记，如果还是有引用链就从即将回收的集合中移除，否则会被GC。
						一个对象没有覆盖finalize()方法或者该方法已经被虚拟机调用过，则被判断为不需要执行该方法。
						finalize()方法的运行代价搞，不确定大，无法保证各个对象的调用顺序。
	4、方法区回收：主要是回收废弃常量和无用的类，性价比较低。而堆尤其是新生代的内存，一次垃圾回收一般可以回收70%-95%的空间。
					废弃常量的回收：类似于回收java堆中的对象，比如没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，在GC时，如有必要会将该常量清理出常量池。常量池的其他类（接口）、方法、字段的符号引用与之类似。
					无用的类的判断，需要同时满足以下三个条件：
						（1）该类的所有实例已经被回收，即java堆中不存在该类的任何实例。
						（2）加载该类的ClassLoader已经被回收
						（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
					满足上述三个条件的无用类可以被回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class和-XX:+TraceClassLoading、-XX:+TraceClassUnLoading来查看类加载和卸载信息。
					在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoder的场景都需要虚拟机具备类卸载功能，以保证永久代不会溢出。
垃圾收集算法
	1、标记-清除（Mark-Sweep）算法：首先标记出所有需要回收的对象，然后在标记完成后统一回收所有被标记对象。
						缺点：（1）效率不高：标记和清除的效率都不高
							  （2）空间问题：会产生大量内存碎片，导致以后需要分配一个较大内存时，无法找到足够大的连续内存而不得不提前触发一次垃圾回收
	2、复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存用完之后，就将还存活着的对象复制到另一块内存中，然后将已使用过的内存一次清理。这样每次只对整个半区进行内存回收，内存分配时也不用考虑内存碎片等问题，只需要移动堆顶指针，按顺序分配内存即可。
				优点：实现简单，运行高效
				缺点：内存缩小了原来的一半。如果对象存活率较高时，复制操作会降低效率。
				现在的商业虚拟机使用该算法来回收新生代。因为新生代中的对象98%是“朝生夕死”的，即生命周期很短，并不需要按照1:1的比例来划分内存空间。所以将内存分成了一个较大的Eden区和两个小的Survivor区（8:1:1），每次使Eden区和一个Survivor区。当垃圾回收时将Eden区和一个Survivor区中的存活对象复制到另一块Survivor空间，最后清理掉Eden和之前用过的Survivor空间。
				当Suvivor空间不够使用时，需要依赖其他内存（老年代）进行分配担保。
	3、标记-整理算法：标记过程与标记清除算法一致，但后续动作不是直接对可回收对象进行清除，而是对所有存活的对象向一端移动，然后清除端边界以外的内存。（老年代）
	4、分代收集算法：根据对象存活周期的不同将内存分为几块，一般是新生代和老年代。然后根据各个年代特点选择适当的收集算法。新生代的对象因为生命周期比较短，所以每次都是大批量的对象死亡，只有少量存活，选择复制算法的成本比较低；而老年代的对象存活率比较高，没有额外的空间可做分配担保，而且复制成本也比较高，因此一般才选择标记清除或者标记整理算法。