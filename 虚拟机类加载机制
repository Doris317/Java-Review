类加载机制：虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。
			java语言中类的加载、连接和初始化的过程都是在运行时期完成的，因此java 具有动态可扩展的语言特性是依赖运行时期动态加载和动态连接的特点实现的。
类的生命周期：加载、验证、准备、解析、初始化、使用、卸载，其中：验证、准备和解析部分称为连接。
			加载、验证、准备、初始化和卸载的顺序是固定的，按顺序开始（不是按顺序进行，因为可以交叉进行），而解析可以在初始化之后，这是为了支持java语言的运行时绑定。
			有且只有5中情况必须立刻对了类进行初始化：
			1、遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时，如果类还没有初始化，要立即对类进行初始化
			2、使用java.lang.reflect包的方法对类进行反射调用的时候
			3、当初始化一个类时，发现其父类还没有初始化，先触发父类的初始化（类，接口只有在用到了其父接口时才会初始化）
			4、虚拟机启动时，包含main方法的类（主类）需要先被虚拟机进行初始化
			5、当使用JDk1.7动态语言支持时，入宫一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄时，并且这个方法句柄所对应的类没有初始化，需要先触发器初始化。
			对于静态字段，只有直接定义这个字段的类才会被初始化。static final修饰的字段在编译期会存入常量池，因此不会导致类的初始化。

类加载的过程：
	1、加载：虚拟机需要通过一个类的全限定名获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据结构的访问入口。
	2、验证：目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。
			1）文件格式验证：验证字节流是否符合Class文件格式的规范，比如魔数、版本号、是否存在不支持的常量类型等
			2）元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。比如是否存在父类，是否继承了不允许被继承的类，是否实现了父类或者父接口之中要求实现的所有方法等，
			3）字节码验证：通过对数据流和控制流分析，确定程序的语义是合法的、符合逻辑的。元数据验证是对数据信息中的数据类型进行分析，而字节码验证是对类的方法体进行验证。比如：确保任意时刻操作数栈的数据类型与指令代码序列都能配合工作，保证跳转指令不会跳转到方法体以外的字节码指令上等。
							StackMapTable：Code属性中的一项属性，用于描述方法体中所有基本块开始时的本地变量表和操作栈应有的状态，字节码验证期间只需要检查该属性中的记录是否合法即可。
			4）符号引用验证：确保解析动作能正常执行。在将符号引用转换为直接引用时，对类自身以外的信息进行匹配校验。比如：符号引用中通过字符串描述的全限定名是否能找到对应的类等。
	3、准备：正式为类变量分配内存并设置变量初始值的阶段。类变量所使用的内存是在方法区中进行分配的。这里的初始值指变量数据类型的零值，但是对于常量final就会被初始化为其设置的值。
	4、解析：虚拟机将常量池的符号引用替换为直接引用的过程。
			 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量（明确当以在JVM规范的Class文件格式中），只要使用时能够准确无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。
			 直接引用：可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。与虚拟机实现的内存布局相关，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标就一定会在内存中。
			 虚拟机并未规定解析阶段发生的具体时间，只规定在执行用于操作符号引用的字节码指令之前，先对他们的符号引用进行解析。
			 除invokedynamic指令外，虚拟机实现对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并将常量标识为已解析）来避免解析动作的重复进行。而invokedynamic指令必须等到程序实际运行到这条指令的时候，解析动作才能进行。
			 主要有以下四种：
				1）类或接口的解析：数组类型加载数组的元素类型，非数组类型加载全限定名所表示的类
				2）字段解析：首先解析字段所属的类或者接口的符号引用，用C表示。如果C中包含了简单名称和字段描述符与目标相匹配的字段，则返回该字段的直接引用；否则，按照先接口后类的顺序从下往上递归搜索简单名称和字段描述符与目标相匹配的字段。找到，返回该字段的直接引用，找不到的话返回java.lang.NoSuchFieldError异常。
							 找到后会进行权限验证，如果不具备访问权限，抛出java.lang.IllegalAccessError异常。
				3）类方法解析:首先解析方法所属的类或者接口的符号引用，用C表示。如果C是接口，直接抛出异常。否则，在C中查找是否包含了简单名称和描述符与目标相匹配的方法,有，返回该方法的直接引用；没有，先父类递归查找，找到返回，找不到在其实现的接口中递归查找，找到，说明是抽象类，返回异常，否则返回查找失败异常。
							  最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。
				4）接口方法解析：首先解析方法所属的类或者接口的符号引用，用C表示。如果C是类，直接抛出异常。否则，在C中查找是否包含了简单名称和描述符与目标相匹配的方法,有，返回该方法的直接引用；没有，在其实现的接口中递归查找，找到返回，找不到，返回查找失败异常。
				5）方法类型解析
				6）方法句柄解析
				7）调用点限定符解析
	5、初始化：准备阶段，为变量赋值了系统要求的零值。而在初始化阶段，需要根据程序员通过程序制定的主观计划去初始化变量和资源。
			   初始化阶段是执行类构造器<clinit()>方法的过程。
			   <clinit()>方法是由编译器自动收集类中的所有类变量的赋值操作和静态语句块中的语句合并而成的。收集顺序是由语句在源文件中出现的顺序决定的。
			   虚拟机会保证<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<clinit()>方法。
			   接口中没有静态语句块，但是会有变量的赋值操作。因此接口也具有<clinit()>方法，但是与类不同的是，在接口中不需要先执行父接口的<clinit()>方法，只有当父接口定义的变量被使用时，才对父接口进行初始化。
			   虚拟机会保证一个类的<clinit()>方法在多线程环境下被正确地加锁，同步。同一个类加载器中，一个类型只会被初始化一次。

类加载器：把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。
		  对于任何一个类，都需要由加载它的类加载器以及这个类本身来确立其在java虚拟机中的唯一性。
		  每一个类加载器，都拥有一个独立的类名称空间。
		  1、双亲委派模型：
				从java虚拟机的角度讲，只存在两种不同的类加载器：1）启动类加载器（C++语言实现，虚拟机的一部分）；2）所有其他的类加载器（由java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader）
				从开发人员的角度看，分为：1）启动类加载器：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数指定的路径中被虚拟机识别的类加载到虚拟机内存中。启动类加载器是不能被java程序直接引用的；
										  2）扩展类加载器：由sun.misc.Launcher$ExtClassLoader实现的，负责加载<JAVA_HOME>\lib\ext目录下，或者被java.ext.dirs系统变量所指定的路径中的所有类库，是可以被开发者直接使用的；
										  3）应用程序类加载器：由sun.misc.Launcher$AppClassLoader实现，该类加载器是getSystemClassLoader()方法的返回值，所以一般称为系统类加载器。负责加载用户路径所指定的类库，开发者可以直接使用该加载器。一般不存在用户自定义的类加载器时，该加载器就是默认的类加载器。
				双亲委派模型要求除了顶层的启动类加载器外，所有的加载器都应该有自己的父类加载器。父子之间的关系一般不是继承，而是以组合的方式实现的。
				工作过程：如果一个类加载器收到了加载类的请求，他首先不会自己去加载这个类，而是把这个请求委派给他的父类加载器去完成。至于当父类加载器反馈自己无法完成这个加载请求，即它的搜索范围内没有找到所需的类时，子类加载器才会尝试自己去架子啊。
				优点：java类随着它的加载器一起具备了一种带有优先级的层次关系，保证了Java程序的稳定运作，且实现简单（实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()中）。避免重复加载 和 避免核心类被篡改
		  2、破坏双亲委派模型：
				1）第一次破坏：由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协，添加了一个findClass()接口。
				   在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法唯一逻辑就是去调用自己的loadClass()。
				2）第二次破坏：模型本身的缺陷导致的，在该模型中，越基础的类由越上层的类加载器去加载。（基础类一般作为被用户代码调用的API）。但是基础类往往可能需要回调用户的代码，这个时候上层类加载器可能不认识这些在用户路径下指定的类库。
							   因此，提出了“线程上下文类加载器”的设计。该类加载器通过java.lang.Thread的setContextClassLoader()方法来设置类加载器，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。
							   Java中所有涉及SPI的加载动作基本都采用这种模式：JNDI、JDBC、JCE、JAXB和JBI等。
							例如：JNDI：JNDI的代码由启动类加载器去加载，但是JNDI的目的是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath路径上的JNDI接口提供者（SPI）的代码，但是启动类加载器是不能找到这些类库的。因此，JNDI可以通过线程上下文类加载器去加载所需要的SPI代码，即父类加载器请求子类加载器去完成加载动作。
				3）第三次破坏：由用户对程序动态性的追求导致的，比如：代码热替换、模块热部署等。
							   OSGi实现模块化热部署的关键就是他自定义的类加载机制的实现。每一个程序模块（OSGi称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，需要将它的类加载器连同Bundle一起换掉以实现代码的热替换。
							   在OSGi环境下，类加载器不再是双亲委派模型中的树结构，而是网状结构，当收到类加载请求时，
								（1）将以java.*开头的类委派给父类加载器加载
								（2）否则，将委派列表名单内的类委派给父类加载器加载
								（3）否则，将import列表中的类委派给Export这个类的bundle的类加载器加载
								（4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载
								（5）否则，查找类是否在自己的Fragment bundle中，如果在，则委派给Fragment Bundle的类加载器加载
								（6）否则，查找Dynamic Import列表的Bundle，委派给对应的Bundle的类加载器加载
								（7）否则，类查找失败