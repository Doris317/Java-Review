# 索引
	索引在mysql中也称为键或者key，比如primary key，unique key或者index key以及fulltext，是存储引擎用于快速查找记录的一种数据结构。
	其中主键和唯一索引还起约束的作用:主键唯一不为空，唯一索引唯一。
	目的：优化查询语句的，但是对增删改数据的性能会不太友好。
	​ 1、在表中有大量数据的前提下，创建索引速度会很慢，因为需要遍历全表
	​ 2、在索引创建完毕后，对表的查询性能会发幅度提升，但是写性能会降低，因为数据的变化需要对应索引的变化
	
## 索引的创建和删除 
1. 创建索引的几种方式：
		1）创建表的时候同步创建索引：除了主键不需要索引名，其他索引都需要索引名
		2）在创建表之后创建索引：create unique index 索引名 on 表名（索引列）
		3）利用alter语句创建索引 alter table 表名 add 索引 索引名（索引列）
2. 删除索引的两种方式：
		1）利用alter语句删除索引 alter table 表名 drop 索引 索引名
		2）：drop 索引 索引名 on 表名

## 常见的索引的数据结构
数据库的文件查找：操作系统的文件是存储磁盘上的。而文件的读取是需要磁盘寻道时间、旋转时间和数据传输时间的。
				  寻道是通过移动磁臂到指定的磁道，然后盘片旋转，磁头定位，最后开始数据读取。
				  局部预读性原理：一旦一个数据被访问到，那么他其后的那些数据很快也要被访问到。所以磁盘每次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内（一页）。
1. B+树
	* B树：子节点树大于2的自平衡的查找树
			无论是叶子结点还是非叶子结点，都含有key和一个指向数据的指针，只要找到某个节点后，就可以根据指针找到磁盘地址从而找到数据。
			特点：假设m阶的B树：每个节点至少有m/2个、至多有m-1个关键字；根节点最少有一个关键字；非递减顺序且平衡
			插入：插入元素后判断当前节点的关键字数量是否符合上述特点，如果超过m-1，就分裂，将中间的关键字放入父节点中
			删除：叶子节点的元素直接删除；非叶子节点的删除需要用后继节点去替代被删除节点，然后根据规则调整。
	* B+树：只有叶子节点存储data，即叶子节点包含了这棵树的所有键值，叶子节点不存储指针。
		有k个子结点的结点必然有k个关键码；
		非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
		树的所有叶结点具有一个指向相邻叶子节点的指针，从而构成一个有序链表，可以按照关键码排序的次序遍历全部记录。
区别：B树因为非叶子节点也存储元素，所以对于区间查询：比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限他需要中序遍历来实现遍历，效率低；
		而B+树只有叶子节点保存元素，且每个叶子节点都存储有指向下一个叶子节点的指针，形成了单链表，所以首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。
	  B+树的元素只保存在叶子节点，所以每一次的元素查找都是同样的深度，即关键字的查询路径相同，因此查询比较稳定；而B树只要查找到元素就可以返回，所以最好的性能是O(1),而最坏的性能是检查到叶子节点。
	  因为B+树的非叶子节点只保存索引而不保存数据，因此同样大小的磁盘页可以容纳更多的节点元素，即磁盘IO的次数就比较少。
2. Hash索引
	Hash索引的底层数据结构是hash表，即一种key-value对的数据存储结构。
	根据key值计算出的hash值对数组长度取模作为数组下标进行存储
	1）利用空间换时间，它的单个元素的查找速度比较快
	2）因为比较的是散列函数计算后的hash值，并不是原值，所以他只能用于等值查询
	3）hash表是不具备按照索引排序的，所以对于区间查找，只能全表查询
	4）因为存在hash碰撞，所以如果存在大量重复值的情况下，hash索引的查找性能比b+树低
	5）不支持最左匹配原则，因为hash索引计算索引值是根据索引列的组合来计算的，因此在查找的时候，是没有办法根据部分索引列来计算hash值去匹配查找的

## 索引的最左匹配特性
	MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。
	因此在设计组合索引的时候，将识别度也就是where语句中使用最频繁的字段放在最左边来提高命中率。
	联合索引的第二个好处是在第一个键相同的情况下，已经对第二个键进行了排序处理。

## 聚簇索引和非聚簇索引
	* 聚簇索引是指B+树的叶子节点存储的是整行数据，这样只要一次索引就可以得到所需数据。也称为主键索引。
		* 优点：对主键的排序查找和范围查找速度非常快。
	* 非聚簇索引是指树的叶子节点存储的是主键的值，查询数据的时候需要根据非聚簇索引查找到的主键值再去主键索引树中查找获取整个记录（回表）。也称为二级索引或者非主键索引。
		但是非主键索引可以通过覆盖索引来避免二次查找。
	* 覆盖索引：一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 
		当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。
		如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。

## 索引的优化
	* 使用唯一索引：可以提高查询时的命中率。当使用作为索引的列具有多个重复值的时候，返回的记录就是多行的，大于等于我们想要查询的结果；
	* 为经常需要排序、分组和联合操作的字段建立索引；
	* 为常作为查询条件的字段建立索引： 对于经常出现在where语句里的列加索引，可以提高查询速度；
	* 限制索引的数目，索引越多，更新和插入的效率越低：因为在数据更新和插入的时候需要更新索引，会降低写效率；
	* 尽量使用数据量少的索引：因为数据量越小，同一磁盘块内可以存储的索引数就越多，可以减少磁盘IO的次数；
	* 组合索引中的尽量把能过滤掉更多数据的字段放在前面：因为MySQL的联合索引在数据查询时遵循最左匹配原则；
	* 尽量使用前缀来索引，针对长文本，TEXT等类型：模糊索引如果通配符在开头的话，根据最左匹配原则，还是需要做一次全表搜索，会降低查找速度；
	* 删除不再使用或者很少使用的索引；
	* 数据是动态变化中的，索引的使用也需要根据数据的变化而变化。

## 数据库慢查询的排查方式
	可以通过explain select语句来查看sql语句的执行计划，从结果中分析索引使用情况。
	当发生数据查询慢，或者数据库IO开销很高的情况，要学会使用show processlist或show full processlist命令查看数据库当前在做什么，哪些SQL执行慢，问题出现在哪里。
	或者启动慢查询日志去寻找问题发生原因。