执行引擎是java虚拟机最核心的组成部分之一。
物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的。而虚拟机的执行引擎是由自己实现的，所以可以自行定制指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。
java虚拟机的执行引擎：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

运行时栈帧结构
	栈帧：用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机栈的栈元素，存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等。在编译时期，局部变量表的大小，操作数栈的深度就已经确定，并且写入方法表的Code属性中。
		  每一个方法从调用开始直至执行完成，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
		  一个线程中的方法调用链可能很长，即可能很多方法同时处于执行状态。但是，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，对应方法称为当前方法。执行引擎运行的所有字节码指令都针对当前栈帧进行。
	局部变量表：一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
				局部变量表的容量以slot（变量槽）为最小单位， slot的长度可以随着处理器和操作系统或者虚拟机的变化而变化。
				一个Slot可以存放一个32位以内（boolean、byte、char、short、int、float、reference和returnAddress）的数据类型，reference类型表示一个对象实例的引用。
				对于64位的数据类型（Java语言中明确的64位数据类型只有long和double），虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。
				虚拟机通过索引定位的方式去使用局部变量表，索引值从0开始至局部变量表的最大数量。访问的是32位数据类型的变量，索引n就代表了使用第n个Slot,如果是64位数据类型，就代表会同时使用n和n+1这两个Slot。
				为了节省栈帧空间，局部变量Slot可以重用，方法体中定义的变量，其作用域并不一定会覆盖整个方法体。如果当前字节码PC计数器的值超出了某个变量的作用域，那么这个变量的Slot就可以交给其他变量。在某些情况下，Slot的复用会直接影响到系统的收集行为。
	操作数栈：当一个方法执行开始时，这个方法的操作数栈是空的，在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。			
			  操作数栈的元素的数据类型必须与字节码指令的序列严格匹配。
			  在概念模型中，一个活动线程中两个栈帧是相互独立的。但大多数虚拟机实现都会做一些优化处理：让下一个栈帧的部分操作数栈与上一个栈帧的部分局部变量表重叠在一起，这样的好处是方法调用时可以共享一部分数据，而无须进行额外的参数复制传递。
			  java虚拟机的解释执行引擎称为“基于栈（操作数栈）的执行引擎”。
	动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接；
			  字节码中方法调用指令是以常量池中的指向方法的符号引用为参数的，有一部分符号引用会在类加载阶段（解析）或第一次使用的时候转化为直接引用，这种转化称为静态解析，另外一部分（invokedynamic）在每次的运行期间转化为直接引用，这部分称为动态连接。
	方法返回地址：当一个方法开始执行时，只有两种方式可以退出这个方法：
					1）正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，可能会有返回值给上层调用者。
					2）异常完成出口：在方法执行过程中遇到了异常，并且该异常没有在方法体内得到处理，无论是虚拟机内部异常还是athrow抛出的异常，只要本方法的异常表中没有搜索到匹配的异常处理器，会导致方法异常退出。异完成出口的方法是不会给上层调用者返回任何返回值的。
				 无论采用何种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。
				 退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。
	附加信息：虚拟机规范允许虚拟机实现向栈帧中添加一些自定义的附加信息，例如与调试相关的信息等。一般会将动态连接、方法返回地址以及其他附加信息一起称为栈帧信息。

方法调用：唯一目的是确定被调用方法的版本（即调用哪一个方法），并不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作。
		  一切方法调用在Class文件中存储的都是符号引用，而不是方法在实际运行时内存布局的入口地址（直接引用）。这是需要在类加载的解析阶段或者运行时才能确定的。
		解析（静态的）：在类加载的解析阶段会将一部分的符号引用直接解析成直接引用，这种解析能成立的前提是：方法在程序运行前已确定可调用版本并且在程序运行期间不会改变，即编译期确定的调用目标，包括：静态方法、私有方法、实例构造器和父类方法，也称为非虚方法。除此之外，还有被final修饰的方法，因为不可被继承，所以也是确定的。
			在Java虚拟机中提供了5条方法调用字节码指令： 
				- invokestatic : 调用静态方法 
				- invokespecial:调用实例构造器方法、私有方法、父类方法 
				- invokevirtual:调用所有的虚方法 
				- invokeinterface:调用接口方法，会在运行时在确定一个实现此接口的对象 
				- invokedynamic:先在运行时动态解析出点限定符所引用的方法，然后再执行该方法，在此之前的4条调用命令的分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。
		分派：
			1、静态分派：编译器重载时是通过参数的静态类型而不是实际类型作为判断依据的，并且静态类型是编译期可知的。所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。典型应用是方法重载。
						 静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。
			2、动态分派：在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。典型应用方法是重写。
			3、单分派和多分派：方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派。
							   单分派是根据一个宗量对目标方法进行选择的；
							   多分派是根据多于一个的宗量对目标方法进行选择的。
							   Java在进行静态分派时，选择目标方法要依据两点：一是变量的静态类型是哪个类型，二是方法参数是什么类型。因为要根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。
							   运行时阶段的动态分派过程，由于编译器已经确定了目标方法的签名（包括方法参数），运行时虚拟机只需要确定方法的接收者的实际类型，就可以分派。因为是根据一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。
							   java语言是一门静态多分派，动态单分派的语言。
			4虚拟机动态分派的实现：动态分派比较频繁并且需要在类的元数据中搜索合适的目标方法，因此需要优化。
								  “稳定优化”手段是：在类的方法区建立一个虚方法表，与此对应，也存在接口方法表。使用虚方法表索引来代替元数据查找以提高性能。其原理与C++的虚函数表类似。
								  虚方法表中存放的是各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类中该方法相同，都指向父类的实现入口。具有相同签名的方法在子类和父类的方法表上应该具有相同的索引号，当类型变换时，只需要更换方法表就可以转换出入口地址。
								  虚方法表一般在类加载的连接阶段进行初始化，准备了类变量的初始值时，虚拟机会把类的方法表也初始化完毕。
								  激进优化：内联缓存、类型继承关系分析技术的守护内联

动态类型语言支持
	JDK7新增加了invokedynamic指令、java.lang.invoke包来是实现“动态类型语言”。
	静态类型语言（强类型语言）：编译期进行类型检查过程的语言，java、c++等。严谨具有稳定性以以及代码达到大规模。
	动态类型语言（弱类型语言）：运行期间进行类型检查，变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型，即变量无类型而变量值才有类型的语言，JavaScript、Python、Ruby、PHP等。灵活性，清晰简洁高效。
	java.lang.invoke包：目的是在之前单纯依靠符号引用来确定调用的目标方法外，提供了一种新的动态确定目标方法的机制，称为Methodhandle。
	Methodhandle与反射的区别：1）反射模拟java代码层次的方法调用，而MethodHandle模拟字节码层次的方法调用；
							  2）反射是重量级对象，包含了方法签名、描述符、以及方法属性表中的各种属性的java端表示方式，而MethodHandle是轻量级对象，仅包含与执行该方法相关的信息。
							  3）反射是只为java语言服务的，而MethodHandle可以服务于所有java虚拟机上的语言，也包括java语言。
	invokedynamic指令：每一处含有invokedynamic指令位置都称为“动态调用点”，该指令的第一个参数不是代表方法符号引用的常量，而是代表动态调用的常量，从该常量中可以获取到3项信息：引导方法、方法类型和名称。其中引导方法的返回值就是真正要执行的目标调用。

基于栈的字节码解释执行引擎
	1、解释执行：只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。
				Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程，因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部，所以Java程序的编译就是半独立实现的。
	2、基于栈的指令集与基于寄存器的指令集：
			java编译器输出的指令流基本上一种基于栈的指令集架构，指令流中的大部分都是零地址指令（即不存在显示的参数），依赖操作数栈进行工作。
				优点：可移植、代码实现紧凑（每个字节对应一条指令），编译器实现更简单（不需要考虑空间分配的问题，因为空间分配都是在栈上操作）
				缺点：执行速度比较慢，指令数量比较多，会进行频繁的内存访问（栈访问），而内存访问也是执行速度的瓶颈。
			基于寄存器的指令集，最典型得是X86的二地址指令集，依赖寄存器进行工作。
				优点：执行速度较快。
				缺点：寄存器由硬件提供，因此会受到硬件的约束。
			举个简单例子，分别使用这两种指令计算1+1的结果，基于栈的指令集会是这个样子： 
				iconst_1
				iconst_1
				iadd
				istore_0
			两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后将结果放回栈顶，最后istore_0把栈顶的值放到局部变量表中的第0个Slot中。
			如果基于寄存器的指令集，那程序可能会是这个样子：
				mov eax, 1
				add eax, 1
			mov指令把EAX寄存器的值设置为1，然后add指令再把这个值加1，将结果就保存在EAX寄存器里面。
			